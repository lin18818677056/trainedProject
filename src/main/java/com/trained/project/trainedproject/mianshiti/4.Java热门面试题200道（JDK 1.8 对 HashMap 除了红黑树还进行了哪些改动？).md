
**JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？**

# Java热门面试题200道
## 4. JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动？

### 简述

除了引入红黑树优化数据结构外，JDK 1.8 还对 HashMap 进行了多项重要改进，包括优化扩容机制、改进哈希计算方式、增强并发安全性等。

### 详细改动

#### 1. 扩容机制优化

**JDK 1.7 扩容方式：**
- 扩容时需要重新计算每个元素的哈希值
- 需要重新确定每个元素在新数组中的位置
- 重新构建链表，元素位置可能发生变化

**JDK 1.8 改进：**
- 引入了更高效的扩容机制
- 利用扩容前后容量的关系（扩容后容量是原容量的2倍）
- 元素要么在原位置，要么在原位置+原容量的位置
- 避免了重新计算哈希值的开销

#### 2. 插入顺序调整

**JDK 1.7 插入方式：**
- 采用头插法插入链表元素
- 新元素插入到链表头部
- 多线程环境下扩容时容易形成环形链表，导致死循环

**JDK 1.8 改进：**
- 采用尾插法插入链表元素
- 新元素插入到链表尾部
- 解决了多线程环境下扩容时的死循环问题
- 提高了HashMap的线程安全性（虽然HashMap本身不是线程安全的）

#### 3. 哈希计算优化

**JDK 1.7 哈希计算：**
- 哈希扰动处理相对简单
- 可能导致更多的哈希冲突

**JDK 1.8 改进：**
- 优化了哈希扰动函数
- 使用 `(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)` 计算哈希值
- 将 hashCode 的高16位和低16位进行异或运算
- 提高了哈希值的随机性，减少哈希冲突

#### 4. 延迟初始化

**JDK 1.7 初始化方式：**
- 创建HashMap时立即初始化数组
- 占用不必要的内存空间

**JDK 1.8 改进：**
- 采用延迟初始化策略
- 首次插入元素时才初始化数组
- 节省内存空间，提高初始化效率

#### 5. 并发安全性增强

**JDK 1.7 问题：**
- 头插法在多线程环境下扩容时可能形成环形链表
- 导致 get 操作时出现死循环

**JDK 1.8 改进：**
- 尾插法避免了环形链表的形成
- 虽然HashMap仍不是线程安全的，但减少了潜在的并发问题

#### 6. 优化遍历方式

**JDK 1.8 新增：**
- 引入了新的遍历方法
- 在entrySet()、keySet()、values()的迭代器实现上进行了优化
- 提高了遍历效率

### 总结
JDK 1.8 对 HashMap 的改动不仅仅是引入红黑树这么简单，还包括了扩容机制、插入顺序、哈希计算、初始化策略等多个方面的优化。这些改动共同提升了 HashMap 的性能和稳定性，使其在高并发场景下更加健壮。虽然 HashMap 本身不是线程安全的容器，但这些优化减少了潜在的并发问题，提高了整体的使用体验。