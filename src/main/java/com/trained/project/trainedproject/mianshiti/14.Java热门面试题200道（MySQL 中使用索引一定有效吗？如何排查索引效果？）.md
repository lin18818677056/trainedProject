MySQL 中使用索引一定有效吗？如何排查索引效果？

# Java热门面试题200道

## 14. MySQL 中使用索引一定有效吗？如何排查索引效果？

不是，MySQL 中使用索引不一定有效。MySQL 的查询优化器会根据查询语句和表结构来决定是否使用索引，在某些情况下，即使列上有索引，优化器也可能选择不使用索引，而是进行全表扫描。

### 索引失效的常见场景

以下是一些常见的导致索引失效的场景：

1.  **对索引列使用函数或进行计算**
    如果在 `WHERE` 子句中对索引列使用了函数（如 `YEAR()`、`LEFT()`）或进行了计算，索引将不会被使用。

    *   **失效的例子：**
        ```sql
        SELECT * FROM users WHERE YEAR(birth_date) = 2023;
        ```
    *   **解决方法：** 将查询重写为不对列使用函数的形式。
        ```sql
        SELECT * FROM users WHERE birth_date >= '2023-01-01' AND birth_date < '2024-01-01';
        ```

2.  **模糊查询以通配符开头**
    使用 `LIKE` 进行模糊查询时，如果通配符 `%` 出现在字符串的开头，索引将失效。

    *   **失效的例子：**
        ```sql
        SELECT * FROM products WHERE name LIKE '%phone';
        ```
    *   **解决方法：** 尽量避免在开头使用通配符。如果业务需求无法改变，可以考虑使用全文索引或其他技术（如 Elasticsearch）。
        ```sql
        -- 这种情况索引会生效
        SELECT * FROM products WHERE name LIKE 'phone%';
        ```

3.  **隐式类型转换**
    当查询条件中的数据类型与列的数据类型不匹配时，MySQL 可能会进行隐式类型转换，这会导致索引失效。常见于字符串类型的列与数字进行比较。

    *   **失效的例子（`phone_number` 为 `VARCHAR` 类型）：**
        ```sql
        SELECT * FROM users WHERE phone_number = 1234567890;
        ```
    *   **解决方法：** 确保查询条件中的值与列的数据类型一致。
        ```sql
        SELECT * FROM users WHERE phone_number = '1234567890';
        ```

4.  **不遵循最左前缀原则**
    对于复合索引（即一个索引包含多个列），查询必须从索引的最左边的列开始，并且不能跳过中间的列。

    *   **例子（索引为 `(col1, col2, col3)`）：**
        ```sql
        -- 索引生效
        SELECT * FROM my_table WHERE col1 = 'A';
        SELECT * FROM my_table WHERE col1 = 'A' AND col2 = 'B';
        SELECT * FROM my_table WHERE col1 = 'A' AND col2 = 'B' AND col3 = 'C';

        -- 索引失效（没有从 col1 开始）
        SELECT * FROM my_table WHERE col2 = 'B';
        SELECT * FROM my_table WHERE col3 = 'C';

        -- 索引部分生效（跳过了 col2）
        SELECT * FROM my_table WHERE col1 = 'A' AND col3 = 'C'; -- 只有 col1 的索引会生效
        ```

5.  **使用 `OR` 连接条件**
    如果 `OR` 连接的条件中，有一个条件没有使用索引，那么整个查询的索引都可能失效。

    *   **解决方法：** 可以考虑将 `OR` 查询拆分为两个查询，然后使用 `UNION ALL` 合并结果。

6.  **使用 `!=` 或 `<>`**
    使用不等于操作符通常会导致全表扫描，因为它们不具有很好的选择性。

7.  **使用 `IS NULL` 和 `IS NOT NULL`**
    `IS NOT NULL` 通常会导致索引失效。`IS NULL` 在某些情况下可以使用索引，但这取决于 MySQL 的版本和数据的分布。

8.  **优化器选择全表扫描**
    对于非常小的表，MySQL 优化器可能会认为全表扫描比使用索引更快，因为使用索引本身也有开销。

### 索引生效但查询仍然缓慢的场景

有时候，即使 `EXPLAIN` 显示查询使用了索引，查询仍然可能很慢。这通常有以下几个原因：

1.  **索引选择性低 (Low Index Selectivity)**
    如果索引列的值重复度很高（例如，一个“性别”列），那么通过索引筛选出的数据量依然很大，查询自然会慢。

2.  **回表查询过多 (Excessive Lookups)**
    如果查询的列没有被索引完全覆盖，MySQL 在通过索引找到主键后，还需要根据主键回到原始表中去获取其他列的数据。这个过程称为“回表”。如果回表的行数太多，会产生大量的随机 I/O，导致查询变慢。

    *   **解决方法：** 尽量使用 **覆盖索引 (Covering Index)**，即让索引包含所有需要查询的字段，这样就可以避免回表。

3.  **返回的行数过多**
    即使查询走了索引，但如果查询结果本身就包含大量的行，那么数据传输和处理也是需要时间的。

### 如何通过 EXPLAIN 排查慢查询

`EXPLAIN` 是排查慢查询的核心工具。除了之前提到的 `type` 和 `key`，我们还需要关注 `Extra` 列，它包含了非常多有用的信息，可以帮助我们定位问题。

```sql
EXPLAIN SELECT name, age FROM users WHERE age > 20 ORDER BY name;
```

#### `Extra` 列的关键信息：

*   **`Using index`**: 这是一个非常好的信号，表示查询使用了覆盖索引，没有发生回表。这是性能最好的情况之一。

*   **`Using where`**: 表示在存储引擎层返回数据后，MySQL 服务器层还需要对这些数据进行一次过滤。这很常见，但如果 `rows` 列的值很大，说明存储引擎返回了大量数据给服务器层去过滤，这可能会慢。

*   **`Using filesort`**: 这是一个**坏信号**，表示 MySQL 无法利用索引来完成排序，必须在内存或磁盘上进行额外的排序操作。这通常是因为 `ORDER BY` 的列和 `WHERE` 的列不一致，或者排序方向与索引不一致。这是导致慢查询的常见原因。

*   **`Using temporary`**: 这是另一个**坏信号**，表示 MySQL 在执行查询时需要创建一个临时表。这通常发生在 `GROUP BY` 或 `UNION` 查询中。临时表如果很小，会在内存中创建；如果很大，则会在磁盘上创建，性能会急剧下降。

#### 综合分析 `EXPLAIN` 结果

一个理想的查询，其 `EXPLAIN` 结果通常是：

*   `type`: `ref`, `eq_ref`, `const`
*   `key`: 有具体使用的索引名
*   `Extra`: `Using index`

一个需要优化的查询，其 `EXPLAIN` 结果可能包含：

*   `type`: `ALL` (全表扫描)
*   `key`: `NULL` (没有使用索引)
*   `Extra`: `Using filesort`, `Using temporary`

通过综合分析 `EXPLAIN` 的这些关键列，你就可以更精确地定位到查询的性能瓶颈，并采取相应的优化措施。
