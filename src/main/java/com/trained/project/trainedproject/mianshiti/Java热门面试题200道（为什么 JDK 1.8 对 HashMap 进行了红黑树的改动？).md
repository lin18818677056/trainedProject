
**为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？**

# Java热门面试题200道

## 3. 为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？

### 简述

JDK 1.8 对 HashMap 的一个重要改进是引入了红黑树数据结构。当链表长度超过一定阈值时（默认为8），链表会转换为红黑树，以提高在哈希冲突严重时的查找效率。

### 改动原因

#### 1. 链表的性能瓶颈

在 JDK 1.8 之前，HashMap 采用数组+链表的结构来解决哈希冲突：
- 当多个元素映射到同一个桶（bucket）时，这些元素会以链表的形式存储
- 在查找元素时，需要遍历链表进行比较，时间复杂度为 O(n)
- 当哈希冲突严重或哈希算法不佳时，链表可能变得很长，导致查询效率急剧下降

#### 2. 红黑树的优势

红黑树是一种自平衡的二叉查找树，具有以下特点：
- 最长路径不会超过最短路径的2倍
- 查找、插入、删除操作的时间复杂度均为 O(log n)
- 相比链表的 O(n)，在元素较多时性能提升显著

#### 3. 性能优化考虑

引入红黑树主要是为了解决极端情况下的性能问题：
- 当链表长度超过阈值（默认为8）且数组长度大于等于64时，链表转换为红黑树
- 当红黑树节点数少于6个时，会退化回链表
- 这种设计既保证了正常情况下的高效性，又解决了极端情况下的性能瓶颈

### 实现细节

#### 转换条件

1. 链表长度超过阈值 TREEIFY_THRESHOLD（默认为8）
2. 数组长度大于等于 MIN_TREEIFY_CAPACITY（默认为64）

#### 退化条件

当红黑树节点数少于 UNTREEIFY_THRESHOLD（默认为6）时，退化为链表。

#### 为什么是8和6？

- 8：根据泊松分布，在负载因子为0.75的情况下，链表长度达到8的概率非常小（小于千万分之一）
- 6：设置较小的退化阈值是为了避免在8左右频繁转换，引入中间值7会造成更多的边界条件判断

### 带来的改进

1. **性能提升**：最坏情况下查询时间复杂度从 O(n) 优化到 O(log n)
2. **安全增强**：防止哈希碰撞攻击导致的性能急剧下降
3. **平衡设计**：兼顾了时间和空间复杂度，避免过早使用红黑树带来的额外开销

### 总结

JDK 1.8 对 HashMap 引入红黑树的改动是一项重要的性能优化措施。通过在链表过长时自动转换为红黑树，显著提升了 HashMap 在哈希冲突严重时的性能表现，同时通过合理的阈值设置避免了不必要的转换开销。这一改动体现了在时间和空间复杂度之间寻求平衡的设计思想。